/*
 * NETCAP - Traffic Analysis Framework
 * Copyright (c) 2017-2020 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package stream

import (
	"fmt"
	"github.com/dreadl0ck/netcap/decoder"
	"path/filepath"
	"testing"

	"github.com/blevesearch/bleve"
	"github.com/mgutz/ansi"

	"github.com/dreadl0ck/netcap/resolvers"
	"github.com/dreadl0ck/netcap/types"
)

/*
 * Exploit Database
 * https://www.exploit-db.com
 */

func exploitDBLookupTest(software *types.Software) *bleve.SearchResult {
	var (
		queryTerm = buildExploitQuery(software.Vendor, software.Product, software.Version)
		query     = bleve.NewQueryStringQuery(queryTerm)
		// query = bleve.NewMatchQuery("Google Chrome")
		search             = bleve.NewSearchRequest(query)
		searchResults, err = decoder.exploitsIndex.Search(search)
	)
	if decoder.debugVulnerabilityTests {
		fmt.Println("query:", queryTerm)
	}
	if err != nil {
		fmt.Println("failed to search for vulnerable software:", err)
		return nil
	}
	return searchResults
}

func TestExploitSearch(t *testing.T) {
	// Load vulnerabilities DB index
	var (
		indexName = filepath.Join(resolvers.DataBaseSource, "exploit-db.bleve")
		err       error
	)
	decoder.exploitsIndex, err = openBleve(indexName)
	if err != nil {
		t.Fatal(err)
	}
	defer closeBleve(decoder.exploitsIndex)

	// TODO: ensure only numeric values in versions
	// +Description:"Sucuri" +Versions:Cloudproxy ?

	for _, s := range decoder.testSoftware {

		if decoder.debugVulnerabilityTests {
			fmt.Println("lookup software", s.Vendor, s.Product, s.Version)
		}
		searchResults := exploitDBLookupTest(s)
		if searchResults == nil {
			t.Fatal("no results")
		}

		// fmt.Println("search for ", software.Product, software.Vendor, software.Version)

		if decoder.debugVulnerabilityTests {
			for _, v := range searchResults.Hits {

				var color string
				doc, _ := decoder.exploitsIndex.Document(v.ID)
				if v.Score > decoder.thresholdNVD {
					color = ansi.Red
				}
				fmt.Println(ansi.Yellow, v.ID, "score", v.Score, ansi.Reset)
				for i, f := range doc.Fields {
					fmt.Println(color, i, f.Name(), string(f.Value()), ansi.Reset)
				}
				fmt.Println("---------------------------------------------------------")
			}
		}
	}
}
